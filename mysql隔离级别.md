#### MVCC
MVCC multi-version concurrency control,多版本并发控制，解决数据库的并发访问高效问题

数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段。
加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得s锁（共享锁，其他事务可以继续加共享锁，但是不能加排他锁），在进行写操作之前要申请并获得x锁（排他锁，其他事务不能再获得任何锁），加锁不成功，则事务进行等待状态，直到加锁成功才继续执行。
解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

##### 事务的四种隔离级别
1. 在数据库操作中，为了保证并发读取数据的正确性，提出了事务的四种隔离级别：分别是：未提交读，已提交读，可重复读，可串行化。innodb默认的级别是可重复读
2. 四种隔离级别：
- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

3. 不可重复读和幻读的区别：
不可重复读：重点在于update和delete,一个事务在查询时，不会查询到其他事务的更新后的数据，即查询时是可重复读的。在可重复读中，第一次读取到数据后，就将这些数据加锁，其他事务无法修改这些数据。
幻读：重点在insert,A事务在在读取了数据后，其他事务插入了数据并写提交，这是A事务再次查询是比之前的查询多了一条数据，这就是幻读。
不可重复读和幻读的区别就是使用了不同的锁机制来解决他们产生的问题

##### 乐观锁和悲观锁
1. 乐观锁
乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题（不会有其他线程对数据进行修改），因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或者CAS算法实现。
2. 悲观锁
总是假设最坏的情况，每次取数据时都任务其他线程会修改，所以都会加锁，一旦加锁，不同线程同时执行时，只能有一个线程执行，其他的线程在入口处等待，直到锁被释放。
读得多，冲突几率小，乐观锁
写得多，冲突几率大，悲观锁


##### Next-key锁
Next-key锁是行锁和GAP锁(间隙锁)的合并
1. 间隙锁：（在可重复读这个隔离级别下，经过测试发现也不会出现幻读的情况，就是因为加了Gap锁）间隙锁就在是B+树存储中数据和数据之间的锁。
2. 行锁防止别的事务修改或者删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的Next-key锁共同解决了RR级别在写数据时的幻读问题。

##### Serializable
1. 可串行化这个级别，读加共享锁，写加排他锁。读写互斥。
2. 使用悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。（所以如果业务并发特别少，或者没有并发，同时又要求诗句及时可靠的话，就需要用这个隔离级别。）
3. 不要看到select就说不会加锁，在S这个级别，还是会加锁的。

https://tech.meituan.com/2014/08/20/innodb-lock.html

```
transaction的读法是/træn'zækʃən/

x的读法是/ɛks/

所以tx分别代表：t - tran; x-saction
```

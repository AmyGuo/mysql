#### 常见问题汇总
##### 一、索引相关：
1. 为什么要用数据库
数据可以保存在内存、文件和数据库三个地方。内存中存取速度快但数据不能用就保存，且内存空间有限；存在文件中的数据可以永久保存但查询不方便且速度慢；存在数据库中的数据可以用就保存，查询方便，管理数据也方便。

2. 数据库三大范式
第一范式：每个列都不可以再拆分
第二范式：在第一范式基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分
第三范式：在第二范式基础上，非主键列只依赖与主键，不依赖与其他非主键
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能，事实上我们经常会为了性能而妥协数据库的设计。

3. mysql有哪些数据类型
    1. 整数类型
    2. 实数类型
    3. 字符串类型
    4. 枚举类型
    5. 日期和时间类型

4. mysql常用存储引擎及他们之间的区别
在mysql中常用的存储引擎主要有2个：innodb和myisam。
- innodb: 新版mysql默认引擎，支持基于主键的聚簇索引，数据缓存，支持外键，行级别锁，MVCC多版本控制，支持事务。
- myisam：老版本mysql默认引擎，不支持事务、行级锁和外键，支持表级锁。
- mysql运行时，innodb会在内存中建立缓冲池，用于缓存数据和索引。但是，该引擎不支持全文索引，同时启动比较慢，也不会存表的行数。当进行select count(*) from table指令时，需要全表扫描。所以当需要使用数据库的事务时，该引擎就是首选，由于锁的力度小，写操作不会锁定全表，因为mvcc所以在高并发的场景下效率也很高。大容量数据时也可选innodb，因为支持事务和可以利用日志来进行故障恢复，主键查询效率也高。
- myisam因为只支持标表级锁，所以当执行插入和更新语句时都需要锁定整张表，效率低下，但是他保存了表的行数，所欲读取时不需要全表扫描。当表的读操作多于写操作且不需要支持事务时，myisam可作为首选


5. myisam索引和innodb的索引的区别
两种索引的数据结构都是B+树，区别在于：
- innodb索引是聚簇索引，myisam索引是非聚簇索引
- innodb的主键索引的叶子节点存储着行数据，因此主键索引非常高效
- myisam索引的叶子节点存储的是行数据的地址，需要再寻址一次才能得到数据
- innodb非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效

6. innodb存储引擎的特性：
- 插入缓存 insert buffer
- 二次写 double write 
- 自适应哈希索引
- 异步IO
- 刷新临接页

7. 使用索引的优缺点
优点：
- 可以大大加快数据的检索速度
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
缺点：
- 时间:创建索引和维护索引要耗费时间
- 空间：索引需要占物理空间

8. 索引类型：
- 主键索引：primary key 
- 唯一索引：unique key 
- 普通索引：index
- 全文索引：fulltext

9. 创建索引的原则：
1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2）较频繁作为查询条件的字段才去创建索引

3）更新频繁字段不适合创建索引

4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)

5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

6）定义有外键的数据列一定要建立索引。

7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8）对于定义为text、image和bit的数据类型的列不要建立索引。

    
10. 百万级别或者以上的数据如何删除
百万级数据的删除会涉及到索引的维护，会消耗额外的io，所以建议是：先删除索引，再删除无用数据，再重新创建索引。比直接删除会快很多。

11. b数和b+树的区别
- b树中键和值可以存放在非叶子节点和叶子节点，b+数中非叶子节点只存键，叶子节点存放键和值
- b+树的叶子节点有一条链相连，而b树的叶子节点各自独立
- 使用B树的好处：B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
- 使用B+树的好处：由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间

12. 聚簇索引和非聚簇索引区别
- 聚簇索引：将数据存储和索引放在一起，遭到索引也就找到了数据
- 非聚簇索引：将数据存储与索引分开结构，非聚簇索引都是辅助索引

13. mysql的innodb为什么使用b+树
B树也是多叉树结构，一种自平衡的树，而且B+树是从B树演化而来的，那么为什么不使用B+树的前身B树呢？从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。根据这个差别可以得出以下结论：

- 磁盘IO读写次数相比B树降低了：在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。
- 每次查询的时间复杂度是固定的：在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。
- 遍历效率更高：由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。
- 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

14. 什么情况下索引会失效
- 如果条件中有or,并且or连接的列包含非索引列
- 对于多列索引，使用时不符合最左前缀原则
- like查询以%开头
- 如果列类型是字符串，那一定要在条件中将数据使用引号引起来，否则不适用索引
- 如果mysql估计使用全表扫描要比使用索引快，则不使用索引
- 在索引列上做计算、函数等任何操作
- 在索引列上使用 != 会导致全表扫描

15. 如何排查慢查询问题
- 慢查询：将超过执行时间的sql语句查询称为慢查询，通常情况来讲，只要返回时间大于1s的查询都可以称为慢查询。慢查询会导致cpu、内存消耗过高，服务器压力增加。
- 慢查询分析三部曲：
    1. explain:查看sql执行计划，判断是否索引利用最大化(不会真的执行sql语句)
    2. profile:详细的列出sql语句在每一个步骤消耗的时间(会执行一遍sql语句)
    3. optmizer_trace:可以看到内部查询计划的trace信息，从而知道mysql是如何在众多索引中选出最优的那一个

16. 慢查询具体分析
- 开启慢查询方法如下，通过分析慢查询日志中的语句，可以对查询语句进行增加索引，优化索引等步骤
```
mysql> show variables like 'long%';

long_query_time | 10.000000


mysql> set long_query_time=1;


mysql> show variables like 'slow%';

slow_launch_time    | 2 (建立线程花费的时间)

slow_query_log      | OFF

slow_query_log_file | /usr/local/mysql/data/amyguo-slow.log

mysql> set global slow_query_log='ON'

less amyguo-slow.log 
/usr/local/mysql/bin/mysqld, Version: 5.7.17 (MySQL Community Server (GPL)). started with:
Tcp port: 3306  Unix socket: /tmp/mysql.sock
Time                 Id Command    Argument
# Time: 2021-03-11T02:21:43.476384Z
# User@Host: root[root] @ localhost []  Id:     4
# Query_time: 0.018671  Lock_time: 0.000101 Rows_sent: 0  Rows_examined: 100000
use gtj_test;
SET timestamp=1615429303;
select * from t where a = 100000000;
# Time: 2021-03-11T02:22:40.406015Z
# User@Host: root[root] @ localhost []  Id:     4
# Query_time: 0.019305  Lock_time: 0.000117 Rows_sent: 0  Rows_examined: 100000
SET timestamp=1615429360;
select * from t where a > 100000000;

```
- 查看当前哪些线程正在运行：show processlist;
```
mysql> show processlist;
+----+------+-----------+----------+---------+------+----------+------------------+
| Id | User | Host      | db       | Command | Time | State    | Info             |
+----+------+-----------+----------+---------+------+----------+------------------+
|  4 | root | localhost | gtj_test | Query   |    0 | starting | show processlist |
+----+------+-----------+----------+---------+------+----------+------------------+

```
- 使用explain来优化查询语句，explain结果各个参数含义如下：
```
explain:
1. id是sql执行的顺序的标识，sql从大到小的执行
id相同时，执行顺序由上至下
如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行
2. select_type 是查询中每个select子句的类型
    SIMPLE， 简单select，不适用union或者子查询等。
    PRIMARY ，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY
    UNION， UNION中的第二个后者后面的select语句
    DEPENDENT UNION， UNION中的第二个或后面的select语句，取决于外面的查询
    UNION RESULT， UNION的结果
    SUBQUERY，子查询中的第一个select
    DEPENDENT SUBQUERY，子查询中的第一个select，取决于外面的查询
    DERIVED，派生表的select，from子句的子查询
    UNCACHEABLE SUBQUERY，一个子查询的结果不能被缓存，必须重新评估外连接的第一行
3. type表示mysql在表中找到所需行的方式，又称访问类型，常用的类型有：ALL,index,range,ref,eq_ref,const,system,NULL(性能从左到右，从差到好)
    ALL，full table scan,遍历全表来找到匹配的行
    index：full index     scan,index和all区别为index类型只遍历索引树。
    range：只检索给定范围的行，使用一个索引来选择行
    ref：表示上述表的连接匹配条件，即哪些列或者常量被用于查找索引列上的值
    eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key 或者unique key作为关联条件（此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较通常都是等号，查询效率高）
    const,system：当mysql对查询某部分进行优化，并转换为一个常量是，使用这些类型方位，如将主键放置于where列表。
4. possible_key指出mysql能使用哪个索引在表中找到记录，查询设计到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。该列完全独立于explain输出所示的表的次序，这意味着在possible_key中的某些键实际上不能按生成的表次序使用。如果该列是NULL，则没有相关的索引，在这种情况下，可以通过检查where子句看是否他引用某些列或者合适索引的列来提高性能查询，如果是这样，创造一个适当的索引并且再用次explain来检查查询。
5. key:此次查询中确切使用到的索引
6. ref:哪个字段或常数与key一起被使用
7. row:显示查询一共扫描了多少行，这是一个预估值
8. filtered:表示此查询条件所过滤的数据的百分比
9. extra：额外的信息
10. table：查询的表名
11. partitions：匹配的分区
```
- 使用profile具体步骤
```
mysql> show variables like 'profil%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| profiling              | OFF   |
| profiling_history_size | 15    |
+------------------------+-------+
2 rows in set (0.00 sec)

mysql> set session profiling = 'on';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> show variables like 'profil%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| profiling              | ON    |
| profiling_history_size | 15    |
+------------------------+-------+
2 rows in set (0.00 sec)

mysql> select * from t where a = 10000000;
Empty set (0.02 sec)

mysql> show profiles;
+----------+------------+------------------------------------+
| Query_ID | Duration   | Query                              |
+----------+------------+------------------------------------+
|        1 | 0.00114175 | show variables like 'profil%'      |
|        2 | 0.01848325 | select * from t where a = 10000000 |
+----------+------------+------------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql> show profile block io,cpu,memory,source for query 2;
+----------------------+----------+----------+------------+--------------+---------------+-----------------------+----------------------+-------------+
| Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | Source_function       | Source_file          | Source_line |
+----------------------+----------+----------+------------+--------------+---------------+-----------------------+----------------------+-------------+
| starting             | 0.000045 | 0.000000 |   0.000000 |            0 |             0 | NULL                  | NULL                 |        NULL |
| checking permissions | 0.000005 | 0.000000 |   0.000000 |            0 |             0 | check_access          | sql_authorization.cc |         835 |
| Opening tables       | 0.000012 | 0.000000 |   0.000000 |            0 |             0 | open_tables           | sql_base.cc          |        5649 |
| init                 | 0.000017 | 0.000000 |   0.000000 |            0 |             0 | handle_query          | sql_select.cc        |         121 |
| System lock          | 0.000007 | 0.000000 |   0.000000 |            0 |             0 | mysql_lock_tables     | lock.cc              |         323 |
| optimizing           | 0.000006 | 0.000000 |   0.000000 |            0 |             0 | optimize              | sql_optimizer.cc     |         151 |
| statistics           | 0.000011 | 0.000000 |   0.000000 |            0 |             0 | optimize              | sql_optimizer.cc     |         367 |
| preparing            | 0.000009 | 0.000000 |   0.000000 |            0 |             0 | optimize              | sql_optimizer.cc     |         475 |
| executing            | 0.000002 | 0.000000 |   0.000000 |            0 |             0 | exec                  | sql_executor.cc      |         119 |
| Sending data         | 0.018190 | 0.017997 |   0.000000 |            0 |             0 | exec                  | sql_executor.cc      |         195 |
| end                  | 0.000010 | 0.000000 |   0.000000 |            0 |             0 | handle_query          | sql_select.cc        |         199 |
| query end            | 0.000007 | 0.000000 |   0.000000 |            0 |             0 | mysql_execute_command | sql_parse.cc         |        5004 |
| closing tables       | 0.000008 | 0.000000 |   0.000000 |            0 |             0 | mysql_execute_command | sql_parse.cc         |        5056 |
| freeing items        | 0.000109 | 0.000000 |   0.000000 |            0 |             0 | mysql_parse           | sql_parse.cc         |        5630 |
| logging slow query   | 0.000036 | 0.000000 |   0.000000 |            0 |             8 | log_slow_do           | log.cc               |        1713 |
| cleaning up          | 0.000011 | 0.000000 |   0.000000 |            0 |             0 | dispatch_command      | sql_parse.cc         |        1901 |
+----------------------+----------+----------+------------+--------------+---------------+-----------------------+----------------------+-------------+
16 rows in set, 1 warning (0.00 sec)
Sending data 并不只是在服务器端和客户端之间 Sending data，还包括了从磁盘读取数据的时间，因为这个查询执行了全表扫描，所以这个时间会比较高，当然索引的效率不高也会导致这部分时间比较久。
```

##### 二、事务相关
1. 事务的概念：
事务是一组不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行结果必须使数据库从一种一致状态变到另一种一致状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

2. 事务的四大特性
- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
- 一致性：事务执行前后，数据保持一致，多个事务对同一数据读取的结果是相同的
- 隔离性；并发访问数据库时，一个事务不会被其他事务所干扰，各并发事务直接数据库时独立的
- 持久性：一个事务一旦被提交，数据库数据的改变时持久的，不会因为数据库发生故障而对其有什么影响

3. 什么时事务的隔离级别，MySQL默认级别时什么
为了达到事务的四大特性，数据库定义了4中不同的事务隔离级别，由低到高依次为未提交读，已提交读，可重复读，串行化，他们分别可以解决脏读，不可重复读和幻读的问题。事务隔离机制的实现是基于锁机制和并发调度。其中并发调度使用的是mvcc,通过保存修改的旧版本信息来支持并发一致性读和回滚等忒性。
- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别（使用mvcc）。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。（但是innodb利用行锁+间隙锁解决了幻读情况）
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

##### 三、锁

##### 四、mysql优化
1. 如何排查慢查询问题
2. mysql高可用的原因
3. 分表策略

https://blog.csdn.net/ThinkWon/article/details/104778621

https://www.php.cn/mysql-tutorials-457109.html

#### 补充

1. mysql的主从复制和读写分离
2. mysql如何保证数据的一致性和持久性
3. 

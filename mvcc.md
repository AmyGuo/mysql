#### MVCC
MVCC multi-version concurrency control,多版本并发控制，解决数据库的并发访问高效问题

数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段。
加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得s锁（共享锁，其他事务可以继续加共享锁，但是不能加排他锁），在进行写操作之前要申请并获得x锁（排他锁，其他事务不能再获得任何锁），加锁不成功，则事务进行等待状态，直到加锁成功才继续执行。
解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

##### 事务的四种隔离级别
1. 在数据库操作中，为了保证并发读取数据的正确性，提出了事务的四种隔离级别：分别是：未提交读，已提交读，可重复读，可串行化。innodb默认的级别是可重复读

2. 四种隔离级别：
- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

3. 不可重复读和幻读的区别：
不可重复读：重点在于update和delete,一个事务在查询时，不会查询到其他事务的更新后的数据，即查询时是可重复读的。在可重复读中，第一次读取到数据后，就将这些数据加锁，其他事务无法修改这些数据。
幻读：重点在insert,A事务在在读取了数据后，其他事务插入了数据并写提交，这是A事务再次查询是比之前的查询多了一条数据，这就是幻读。
不可重复读和幻读的区别就是使用了不同的锁机制来解决他们产生的问题

##### 乐观锁和悲观锁
1. 乐观锁
乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题（不会有其他线程对数据进行修改），因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或者CAS算法实现。
2. 悲观锁
总是假设最坏的情况，每次取数据时都任务其他线程会修改，所以都会加锁，一旦加锁，不同线程同时执行时，只能有一个线程执行，其他的线程在入口处等待，直到锁被释放。
读得多，冲突几率小，乐观锁
写得多，冲突几率大，悲观锁


https://tech.meituan.com/2014/08/20/innodb-lock.html

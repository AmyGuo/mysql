#### MVCC
> MVCC multi-version concurrency control,即多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

##### 1. mvcc在mysql生效的隔离级别
1. 在mysql的innodb引擎中就是指在已提交读和可重复读这两种隔离级别下的事务对于select操作会访问版本链中的记录的过程。
2. 另外两个隔离级别和mvcc不兼容，因为未提交读总是读取到最新的数据行，而不是符合当前事务版本的数据行。而串行化级别则会对所有读取的行都加锁。

##### 2. 为什么需要MVCC
为什么需要MVCC呢？数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。

##### 3. 版本链
【版本链存在于undo日志中】（undo日志除了用于实现mvcc，还用于事务的回滚）
1. 在innodb引擎表中，它的聚簇索引记录中有两个必要的隐藏列：
    1. trx_id:这个id用来存储每次对某条聚簇索引记录进行修改时的事务id
    2. roll_pointer:每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条记录的上一个版本的位置，通过它来获得上一个版本的记录信息。（注意，插入操作的undo日志没有这个属性，因为他没有老版本）
2. ReadView:
    1. 已提交读和可重复读的区别就在于它们生成ReadView的策略不同，已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView，而可重复读则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。
    2. ReadView中有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务，通过这个列表来判断记录的某个版本是否对当前事务可见。
    
    
##### 4. mysql中的日志：
binlog,redolog,undolog

binlog，是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。

redo log记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中, redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。

undo log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。

参考：
https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc
https://zhuanlan.zhihu.com/p/66791480
